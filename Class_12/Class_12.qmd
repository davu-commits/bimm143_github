---
title: "Class 12: RNA Seq Analysis"
author: "Dan Vu (PID: A17380158)"
format: pdf
toc: TRUE
---

## Background
Today we will analyze some RNASeq data from Himes et al. on the effects of a common steroid on airway smooth muscle cells (ASM cells).

Our starting point is the "counts" data and "metadata" that contain the count values for each gene in their different experiments (i.e. cell lines with or without the drug)

## Data import

```{r}
metadata <- read.csv("airway_metadata.csv")
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
```

Let's see what these datasets look like

```{r}
head(counts)
```

```{r}
head(metadata)
```

> Q1. How many genes are in this dataset? 

```{r}
nrow(counts)
```

> Q2. How many different experiments are there? How many "control" cell lines are there?

```{r}
nrow(metadata)
sum(metadata$dex == "control")
```
There are 4 experimental 'control' cell lines and 4 'control' cell lines.

## Toy with differential gene expression

To start our analysis let's calculate the mean counts for all genes in the "control" experiments.

1. Extract all "control" columns from the `counts` object.
2. Calculate the mean for all rows(i.e. genes) of these "control" columns.

3-4. Do the same for "treated"
5. Compare these with `control.mean` values to see if theres any significant difference.

```{r}
library(dplyr)
```

```{r}
control.inds <- metadata$dex == "control"
control.counts <- counts[,control.inds]
```

```{r}
meanrows.control.counts <- rowMeans(control.counts)
```

> Q3. How would you make the above code in either approach more robust? Is there a function that could help here?

Yes, the above code could be more robust with the function `rowMeans`.

> Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

Now let's do the same for the experimental cells.

```{r}
treated.inds <- metadata$dex == "treated"
treated.counts <- counts[,treated.inds]
```

```{r}
meanrows.treated.counts <- rowMeans(treated.counts)
```

```{r}
meancounts <- data.frame(meanrows.control.counts, meanrows.treated.counts)
head(meancounts)
plot(meancounts)
```

```{r}
plot(meancounts, log="xy")
```

> Q5.You could also use the ggplot2 package to make this figure producing the plot below. What geom_?() function would you use for this plot?

I would use the `geom_point()` function.

> Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this?

The argument is `plot(meancounts, log="xy")`.

We often talk metrics like "log2 fold-change"

```{r}
# treated/control
log2(10/10)
```
```{r}
log2(10/40)
```

Let's calculate the log2 fold change for our treated over control mean counts.

```{r}
meancounts$log2fc <- 
log2(meancounts$meanrows.treated.counts / 
       meancounts$meanrows.control.counts)
```

```{r}
head(meancounts)
```

```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```

> Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

The purpose of the `arr.ind` argument in the which() function is to report the positions where there are any "TRUE" values, allowing us to ignore any zero counts.

A common "rule of thumb" is a log2 fold change cutoff of +2 or -2 to call genes "Up regulated" or "Down regulated".

> Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level?

This is the number of up-regulated genes.
```{r}
sum(meancounts$log2fc >= +2, na.rm = T)
```

> Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level?

This is the number of down-regulated genes.
```{r}
sum(meancounts$log2fc <= -2, na.rm = T)
```
> Q10. Do you trust these results? Why or why not?

Although these fold changes are large, whether or not they are considered statistically significant between the two types of cell lines is still to be determined, so these results cannot be trusted.

## DESeq2 Analysis

```{r, message = FALSE}
library(DESeq2)
```

For DESeq2 analysis we need three things.
- count values (contData)
- metadata telling us about the columns in `countData` (`colData`)
- design of the experiment (i.e. what do you want to compare)

Our first function from DESeq2 will setup the input required for analysis by storing all these 3 things together.

```{r}
dds <- DESeqDataSetFromMatrix(countData = counts,
                              colData = metadata,
                              design = ~dex)
```

The main function in DESeq2 that runs the analysis is called `DESeq()`

```{r}
dds <- DESeq(dds)
```


```{r}
res <- results(dds)
head(res)
```

## Adding Annotation Data

```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```

```{r}
columns(org.Hs.eg.db)
```


```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",        # The format of our genenames
                     column="SYMBOL",          # The new format we want to add
                     multiVals="first")
head(res)
```
> Q11. Run the mapIds() function two more times to add the Entrez ID and UniProt accession and GENENAME as new columns called res$entrez, res$uniprot and res$genename.

```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

res$uniprot <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="UNIPROT",
                     keytype="ENSEMBL",
                     multiVals="first")

res$genename <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="GENENAME",
                     keytype="ENSEMBL",
                     multiVals="first")

head(res)
```

## Volcano Plot

This is a common summary result figure from these types of experiments and plot the log2 fold-change vs the p-value

```{r}
plot(res$log2FoldChange, -log(res$padj))
abline(v=c(-2,2), col="red")
abline(h=-log(0.04), col="red")
```


## Save our results

```{r}
write.csv(res, file="my_results.csv")
```

## Add gene annotation

To help make sense of our results and communicate them to other folks we need to addd some more annotation to our main `res` object.

We will use two packages to first map IDs to different formats including the classic gene "symbol" gene name. 

```{r}
library(AnnotationDbi)
library(org.Hs.eg.db)
```

Let's see what is in the second package and what exactly it can do for us.

```{r}
columns(org.Hs.eg.db)
```

We can translate or "map" IDs between any of these 26 databases using the `mapIDs()` function.

```{r}
res$symbol <- mapIds(keys = row.names(res), 
       keytype = "ENSEMBL",   
       x = org.Hs.eg.db,     
       column = "SYMBOL"    
       )
head(res)
```

Add the mappings for "GENENAME" and "ENTREZID" and sore as `res$genename` and `res$entrez`.

```{r}
res$genename <- mapIds(keys = row.names(res), 
       keytype = "ENSEMBL",   
       x = org.Hs.eg.db,     
       column = "GENENAME"    
       )
head(res)
```
```{r}
res$entrezid <- mapIds(keys = row.names(res), 
       keytype = "ENSEMBL",   
       x = org.Hs.eg.db,     
       column = "ENTREZID"    
       )
head(res)
```

##Pathway Analysis

There are lots of bioconductor packages to do this type of analysis.

For now let's try one called **gage**.

```{r}
library(gage)
library(gageData)
library(pathview)
```
To use **gage** I need two things.

- a names vector of fold-change values for our DEGs (our geneset of interest)
- a set of pathways or genesets to use for annotation

```{r}
c("barry" = 5, "lisa" = 10)
```

```{r}
foldchanges <- res$log2FoldChange
names(foldchanges) <- res$symbol
head(foldchanges)
```

```{r}
data("kegg.sets.hs")
keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

In our results object we have:

```{r}
attributes(keggres)
```

```{r}
head(keggres$less, 3)
```

Let's look at one of these pathways (hsa05310 Asthma) with our genes colored up so we can see the overlap.

```{r}
pathview(pathway.id = "hsa05130", gene.data = foldchanges)
```

Add this pathway figure to our lab report.

![](hsa05130.pathview.png)

## Save our main results

```{r}
write.csv(res, file="myresults_annotated.csv")
```

